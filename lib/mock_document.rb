# frozen_string_literal: true

require 'stringio'
require 'filemagic/ext'

module Colore
  # Generates mock documents for development purposes.
  # When a document is not found and MOCK_DOCUMENTS_ENABLED=true,
  # this class creates realistic mock documents that allow development
  # without copying production data.
  class MockDocument
    attr_reader :doc_key

    # Constructor
    # @param doc_key [DocKey] The document identifier
    def initialize(doc_key)
      @doc_key = doc_key
    end

    # Returns a random author from the configured list of mock document authors
    # Reads directly from ENV for runtime flexibility (no rebuild needed to change authors)
    # @return [String]
    def random_author
      authors_string = ENV['MOCK_DOCUMENT_AUTHORS'] || 'Mock System'
      authors = authors_string.split(',').map(&:strip)
      authors.sample
    end

    # Returns the title of the mock document
    # @return [String]
    def title
      "Mock Document - #{@doc_key.doc_id}"
    end

    # Returns an array of mock version identifiers
    # @return [Array<String>]
    def versions
      ['v001']
    end

    # Returns the current version identifier
    # @return [String]
    def current_version
      'v001'
    end

    # Checks if the document has the specified version
    # @param version [String] the version identifier
    # @return [Bool]
    def has_version?(version)
      versions.include?(version) || version == 'current'
    end

    # Retrieves a mock file from the document
    # @param _version [String] the version identifier (unused, for interface compatibility)
    # @param filename [String] the name of the file
    # @return [Array<String, StringIO>] [mime_type, file_body]
    def get_file(_version, filename)
      # Generate mock file content based on filename extension
      content = generate_mock_file_content(filename)
      mime_type = content.mime_type

      [mime_type, content]
    end

    # Returns the URL query path for the given file
    # @param version [String] the version identifier
    # @param filename [String] the name of the file
    # @return [String]
    def file_path(version, filename)
      "/document/#{@doc_key.app}/#{@doc_key.doc_id}/#{version}/#{filename}"
    end

    # Summarises the mock document as a Hash
    # @return [Hash]
    def to_hash
      author = random_author
      {
        app: @doc_key.app,
        doc_id: @doc_key.doc_id,
        title: title,
        current_version: current_version,
        versions: {
          v001: {
            txt: {
              content_type: 'text/plain',
              filename: 'document.txt',
              path: file_path('v001', 'document.txt'),
              size: 150,
              author: author,
              created_at: Time.now,
            },
            pdf: {
              content_type: 'application/pdf',
              filename: 'document.pdf',
              path: file_path('v001', 'document.pdf'),
              size: 5000,
              author: author,
              created_at: Time.now,
            },
          },
        },
      }
    end

    private

    # Generates mock file content based on file extension
    # @param filename [String] the filename
    # @return [String] the mock file content
    def generate_mock_file_content(filename)
      extension = File.extname(filename).downcase.delete('.')

      case extension
      when 'txt'
        "This is a mock document.\n\nDocument ID: #{@doc_key.doc_id}\nApplication: #{@doc_key.app}\n\n" \
        "This file is automatically generated for development purposes.\n" \
        "It allows you to test document retrieval without copying production data.\n"
      when 'pdf'
        # Minimal valid PDF structure
        "%PDF-1.4\n" \
        "1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj\n" \
        "2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj\n" \
        "3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj\n" \
        "4 0 obj\n<< /Length 44 >>\nstream\nBT /F1 12 Tf 100 700 Td (Mock PDF Document) Tj ET\nendstream\nendobj\n" \
        "5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>\nendobj\n" \
        "xref\n0 6\n0000000000 65535 f\n0000000009 00000 n\n0000000058 00000 n\n0000000115 00000 n\n0000000240 00000 n\n0000000336 00000 n\n" \
        "trailer\n<< /Size 6 /Root 1 0 R >>\n" \
        "startxref\n433\n%%EOF"

      when 'docx'
        # Return binary content that mimics a docx structure
        # docx files are zip archives with XML content
        # For mock purposes, we create a minimal valid ZIP structure
        require 'zlib'

        # Create a simple DOCX-like binary structure
        # This is a minimal ZIP file containing a document.xml
        "PK\x03\x04\x14\x00\x00\x00\b\x00Mock DOCX Document for development purposes"
      when 'html'
        "<html><head><title>Mock Document</title></head><body>" \
        "<h1>Mock Document</h1>" \
        "<p>Document ID: #{@doc_key.doc_id}</p>" \
        "<p>Application: #{@doc_key.app}</p>" \
        "<p>This file is automatically generated for development purposes.</p>" \
        "</body></html>"
      when 'json'
        {
          doc_id: @doc_key.doc_id,
          app: @doc_key.app,
          title: title,
          type: 'mock',
          message: 'This is a mock document generated for development purposes',
        }.to_json
      else
        # Default to plain text
        "Mock document file: #{filename}\n" \
        "Document ID: #{@doc_key.doc_id}\n" \
        "Application: #{@doc_key.app}\n"
      end
    end
  end
end
